#include <iostream>
#include <windows.h>
#include <vector>
#include <ctime>
#include <conio.h>
#include <stack>

using namespace std;

void gotoxy(int x, int y)
{
    COORD p = { x ,y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), p);
}

enum ConsoleColor
{
    BLACK = 0,
    BLUE = 1,
    GREEN = 2,
    CYAN = 3,
    RED = 4,
    MAGENTA = 5,
    BROWN = 6,
    LIGHT_GRAY = 7,
    DARKGRAY = 8,
    LIGHT_BLUE = 9,
    LIGHT_GREEN = 10,
    LIGHT_CYAN = 11,
    LIGHT_RED = 12,
    LIGHT_MAGENTA = 13,
    YELLOW = 14,
    WHITE = 15
};

void setColor(int background, int text)
{
    HANDLE hStd0ut = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hStd0ut, (WORD)((background << 4) | text));
}

const int BORDER = 100;
const int EMPTY_CELL = 0;
const int MINE = 10;

class Map
{
private:
    int size;
    vector<vector<int>> map;
    vector<vector<int>> mask;
public:
    Map()
    {
        size = 20;
    }

    int openCell(int x, int y)
    {
        int result = 1;
        mask[x][y] = 1;
        if (map[x][y] == MINE)
        {
            result = MINE;
        }
        else if (map[x][y] == EMPTY_CELL)
        {
            result = EMPTY_CELL;
        }
        show();
        return result;
    }


    bool isBorder(int x, int y)
    {
        if (x < 0 || x >= size)
        {
            return false;
        }

        if (y < 0 || y >= size)
        {
            return false;
        }

        if (map[x][y] == BORDER)
        {
            return true;
        }
        return false;
    }

    void initVec(vector <vector<int>> & vec)
    {
        for (int i = 0; i < size; i++)
        {
            vector<int> temp;
            for (int j = 0; j < size; j++)
            {
                if (i == 0 || j == 0 || i == size - 1 || j == size - 1)
                {
                    temp.push_back(BORDER);
                }
                else
                {
                    temp.push_back(EMPTY_CELL);
                }
            }
            vec.push_back(temp);
        }
    }
    
    void initMap()
    {
        initVec(map);
    }

    void initMask()
    {
        initVec(mask);
    }

    void coutColor(char ch, int color)
    {
        setColor(WHITE, color);
        cout << ch;
        setColor(WHITE, BLACK);
    }

    void show()
    {
        gotoxy(0, 0);
        for (int i = 0; i < size; i++)
        {
            for (int j = 0; j < size; j++)
            {
                if (mask[j][i] == EMPTY_CELL)
                {
                    cout << ".";
                    continue;
                }

                if (map[j][i] == BORDER)
                {
                    coutColor('#', LIGHT_BLUE);
                }
                else if (map[j][i] == EMPTY_CELL)
                {
                    cout << " ";
                }
                else if (map[j][i] == MINE)
                {
                    cout << "*";
                }
                else if (map[j][i] == 1)
                {
                    coutColor('1', BLUE);
                }
                else if (map[j][i] == 2)
                {
                    coutColor('2', GREEN);
                }
                else if (map[j][i] == 3)
                {
                    coutColor('3', RED);
                }
                else if (map[j][i] == 4)
                {
                    coutColor('4', MAGENTA);
                }
                else if (map[j][i] == 5)
                {
                    coutColor('5', BROWN);
                }
                else if (map[j][i] == 6)
                {
                    coutColor('6', DARKGRAY);
                }
                else if (map[j][i] == 7)
                {
                    coutColor('7', LIGHT_GREEN);
                }
                else if (map[j][i] == 8)
                {
                    coutColor('8', LIGHT_CYAN);
                }
                else if (map[j][i] >= 1 )
                {
                    cout << map[j][i];
                }
            }
            cout << endl;
        }
    }


    // СЛУЧАЙНАЯ РАССТАНОВКА МИН
    void setRandMines(int numMines)
    {
        if (numMines >= (size - 2) * (size - 2))
        {
            cout << "Too many mines" << endl;
            return;
        }

        for (int i = 0; i < numMines; i++)
        {
            int x = 0;
            int y = 0;
            do {
                x = rand() % (size - 2) + 1;
                y = rand() % (size - 2) + 1;
            } while (map[x][y] == MINE);


            map[x][y] = MINE;
        }
    }

    // РАССТАНОВКА ЧИСЕЛ НА ИГРОВОМ ПОЛЕ
    void setDigits()
    {
        int d = 0;
        for (int i = 1; i < size - 1; i++)
        {
            for (int j = 1; j < size - 1; j++)
            {
                if (map[j][i] == MINE)
                {
                    continue;
                }
                if (map[j][i + 1] == MINE)
                {
                    d++;
                }
                if (map[j][i - 1] == MINE)
                {
                    d++;
                }
                if (map[j + 1][i + 1] == MINE)
                {
                    d++;
                }
                if (map[j + 1][i - 1] == MINE)
                {
                    d++;
                }
                if (map[j - 1][i - 1] == MINE)
                {
                    d++;
                }
                if (map[j + 1][i] == MINE)
                {
                    d++;
                }
                if (map[j - 1][i] == MINE)
                {
                    d++;
                }
                map[j][i] = d;
                d = 0;
            }
        }
    }

    void fill(int px, int py)
    {
        stack <int> stk;
        stk.push(px);
        stk.push(py);

        int x = 0, y = 0;

        while (true) 
        {
            y = stk.top();
            stk.pop();
            x = stk.top();
            stk.pop();

            if (map[x][y + 1] == EMPTY_CELL && mask[x][y + 1] == 0)
            {
                stk.push(x);
                stk.push(y + 1);
            }
            mask[x][y + 1] = 1;
            if (map[x][y - 1] == EMPTY_CELL && mask[x][y - 1] == 0)
            {
                stk.push(x);
                stk.push(y - 1);
            }
            mask[x][y - 1] = 1;
            if (map[x + 1][y + 1] == EMPTY_CELL && mask[x + 1][y + 1] == 0)
            {
                stk.push(x + 1);
                stk.push(y + 1);
            }
            mask[x + 1][y + 1] = 1;
            if (map[x + 1][y - 1] == EMPTY_CELL && mask[x + 1][y - 1] == 0)
            {
                stk.push(x + 1);
                stk.push(y - 1);
            }
            mask[x + 1][y - 1] = 1;
            if (map[x - 1][y + 1] == EMPTY_CELL && mask[x - 1][y + 1] == 0)
            {
                stk.push(x - 1);
                stk.push(y + 1);
            }
            mask[x - 1][y + 1] = 1;
            if (map[x - 1][y - 1] == EMPTY_CELL && mask[x - 1][y - 1] == 0)
            {
                stk.push(x - 1);
                stk.push(y - 1);
            }
            mask[x - 1][y - 1] = 1;
            if (map[x - 1][y] == EMPTY_CELL && mask[x - 1][y] == 0)
            {
                stk.push(x - 1);
                stk.push(y);
            }
            mask[x - 1][y] = 1;
            if (map[x + 1][y] == EMPTY_CELL && mask[x + 1][y] == 0)
            {
                stk.push(x + 1);
                stk.push(y);
            }
            mask[x + 1][y] = 1;
            if (stk.empty())
            {
                break;
            }
        }
    }
};

class Keyboard
{
private:
    int ch = 0;
public:

    Keyboard()
    {
        ch = 0;
    }

    void waitKey()
    {
        ch = _getch();
    }

    int getKey()
    {
        return ch;
    }

};

class Cursor
{
private:
    int x = 1;
    int y = 1;

    int tx = 1;
    int ty = 1;

public:
    void save()
    {
        tx = x;
        ty = y;
    }

    void undo()
    {
        x = tx;
        y = ty;
    }

    void incX()
    {
        x++;
    }

    void decX()
    {
        x--;
    }

    void incY()
    {
        y++;
    }

    void decY()
    {
        y--;
    }

    int getX()
    {
        return x;
    }

    int getY()
    {
        return y;
    }

    void move()
    {
        gotoxy(x, y);
    }

};

class Game {
private:
    void showLogo()
    {
        gotoxy(53, 15);
        cout << "Minesweeper" << endl;
        Sleep(2000);
        system("cls");
    }
public:

    void gameOver()
    {
        gotoxy(53, 15);
        cout << "Game over";
        Sleep(2000);
        gotoxy(0, 15);
        system("pause");
    }

    void run()
    {
        showLogo();
        Map map;
        map.initMap();
        map.initMask();
        map.setRandMines(99);
        map.setDigits();
        map.show();

        Keyboard kb;
        Cursor cs;

        cs.move();

        bool exit = false;

        while (!exit)
        {
            kb.waitKey();
            cs.save();

            switch (kb.getKey())
            {
                case 77: cs.incX();; break; // right
                case 80: cs.incY(); break; // down
                case 75: cs.decX(); break; // left
                case 72: cs.decY(); break; // up
                case 13: 
                    int result = map.openCell(cs.getX(), cs.getY());
                    if (result == MINE)
                    {
                        gameOver();
                        exit = true;
                    }
                    if (result == EMPTY_CELL)
                    {
                        map.fill(cs.getX(), cs.getY());
                        map.show();
                    }
                    break;
            }

            if (map.isBorder(cs.getX(), cs.getY()))
            {
                cs.undo();
            }
            cs.move();    
        }
    }
};

int main()
{
    srand(time(0));
    rand();
    Game game;
    game.run();
}
